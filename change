--- a/libft/Makefile
 %.o: %.c
-	$(CC) $(CFLAGS) -c $< -o $@
+	$(CC) $(CFLAGS) -g -gdwarf-4 -c $< -o $@







--- a/parsing/in.c
 char	**in_one(t_parsed *node, char **split, int *code, int i)
 {
 	duck_fishing(split, i);
-	if (!split[i] || (split[i] && is_problem_char(split[i]) == 1))
+	if (!split[i] || (split[i] && is_problem_char(split[i], code) == 1))
 	{
 		if (!split[i])
 		{



 char	**in_two(t_parsed *node, char **split, int *code, int i)
 {
 	duck_fishing(split, i);
-	if (!split[i] || (split[i] && is_problem_char(split[i]) == 1))
+	if (!split[i] || (split[i] && is_problem_char(split[i], code) == 1))
 	{
 		if (!split[i])
 		{



char	**in_two(t_parsed *node, char **split, int *code, int i)
 		}
 		return (free_chain(node), NULL);
 	}
-	limiter(split[i]);
 	duck_fishing(split, i--);
 	return (split);
 }





--- a/parsing/in_and_out.c
char	**in(t_parsed *node, char **split, int *code)
 	i = -1;
 	while (split[++i])
 	{
-		if (ft_strnstr(split[i], "<", 2))
+		ft_strncmp(split[i], "<<", 3);
+		if (!ft_strncmp(split[i], "<<", 3))
 		{
-			if (!in_one(node, split, code, i))
+			if (!in_two(node, split, code, i))
 				return (NULL);
 		}
-		else if (ft_strnstr(split[i], "<<", 3))
+		else if (!ft_strncmp(split[i], "<", 2))
 		{
-			if (!in_two(node, split, code, i))
+			if (!in_one(node, split, code, i))
 				return (NULL);
 		}
 	}



char	**out(t_parsed *node, char **split, int *code)
 	i = -1;
 	while (split && split[++i])
 	{
-		if (ft_strnstr(split[i], ">", 2) && split[i][1] != '>')
+		if (!ft_strncmp(split[i], ">>", 3))
 		{
-			if (!out_one(node, split, code, i))
+			if (!out_two(node, split, code, i))
 				return (NULL);
 			i = 0;
 		}
-		else if (ft_strnstr(split[i], ">>", 3))
+		else if (!ft_strncmp(split[i], ">", 2) && split[i][1] != '>')
 		{
-			if (!out_two(node, split, code, i))
+			if (!out_one(node, split, code, i))
 				return (NULL);
 			i = 0;
 		}













--- a/parsing/out.c
char	**out_one(t_parsed *node, char **split, int *code, int i)
 {
 	duck_fishing(split, i);
 	i = skip_ispaces(split, ++i);
-	if (!split[i] || (split[i] && is_problem_char(split[i]) == 1))
+	if (!split[i] || (split[i] && is_problem_char(split[i], code) == 1))
 	{
 		if (!split[i])
 		{
 			*code = 2;
 			printf("Syntax error near unexpected token `newline'\n");
 		}
-		node->outfile = ft_strdup("/dev/null");
-		if (!node->outfile)
-			return (free_chain(node), NULL);
-		node->out_mode |= O_WRONLY;
-		return (split);
+		return (free_chain(node), NULL);
 	}
 	node->outfile = ft_strdup(split[i]);
 	if (!node->outfile)








char	**out_two(t_parsed *node, char **split, int *code, int i)
 {
 	duck_fishing(split, i);
 	i = skip_ispaces(split, ++i);
-	if (!split[i] || (split[i] && is_problem_char(split[i]) == 1))
+	if (!split[i] || (split[i] && is_problem_char(split[i], code) == 1))
 	{
 		if (!split[i])
 		{
 			*code = 2;
 			printf("Syntax error near unexpected token `newline'\n");
 		}
-		node->outfile = ft_strdup("/dev/null");
-		if (!node->outfile)
-			return (free_chain(node), NULL);
-		node->out_mode |= O_APPEND;
-		return (split);
+		return (free_chain(node), NULL);
 	}
 	node->outfile = ft_strdup(split[i]);
 	if (!node->outfile)













--- a/parsing/parser.c
char	**handle_env(char **envp, char **split, int *code, int *i)
 	char	*temp;

 	path = NULL;
-	while (split[*i] && ft_strchr(split[*i], '$') && split[*i][0] != '\'' \
-		&& split[*i][find_money(split[*i])] != '\0')
+	while (split[*i] && ft_strchr(split[*i], '$') \
+		&& split[*i][find_money(split[*i])] != '\0' && (ft_strchr(split[*i], '$') - 1)[0] != '\'')
 	{
 		if (ft_strnstr(split[*i], "<<", 3))
 			break ;


















--- a/parsing/parser_utils.c
char	*uh(char *new, char *str, int *code, int i)
 		return (NULL);
 	ft_strlcat(new, str, i);
 	ft_strlcat(new, nb, ft_strlen(nb) + 1);
-	ft_strlcat_mod(new, str + i + 2, ft_strlen(str + i + 2));
-	new[ft_strlen(str) - 2 + ft_strlen(nb) + 1] = '\0';
+	ft_strlcat_mod(new, str + i + 1, ft_strlen(str + i + 2));
 	free(nb);
 	return (new);
 }



int	find_money(char *str)
 	int	i;

 	i = 0;
-	while (str[i] && ((i > 0 && str[i - 1] != '$') || str[i] == ' ' \
+	while (str[i] && ((str[i] == '$' && str[i + 1] && str[i + 1] != '$') || str[i] == ' ' \
 		|| str[i] == '"'))
 		i++;
 	return (i);
 }




-int	is_problem_char(char *str)
+int	is_problem_char(char *str, int *code)
 {
 	if (str[0] == ')' \
 		|| str[0] == '}' || str[0] == '<' || str[0] == '>' || str[0] == '|')
 	{
+		*code = 2;
 		printf("Syntax error near unexpected token `%c'\n", (str[0]));
 		return (1);
 	}














--- a/parsing/parsing.h
 //out
+int	skip_ispaces(char **split, int i);
 char		**out_one(t_parsed *node, char **split, int *code, int i);
 char		**out_two(t_parsed *node, char **split, int *code, int i);

 //parser
 t_parsed	*parse(char **envp, char *rl, int *code);
-int			is_problem_char(char *str);
 char		**handle_env(char **envp, char **split, int *code, int *i);
 char		*replace_var(char *str, char *path, int *code);

 //parser_utils
 t_parsed	*trimm_struct(t_parsed *parsed);
 char		*uh(char *neew, char *str, int *code, int i);
+int			is_problem_char(char *str, int *code);
 int			find_money(char *str);
-int			is_problem_char(char *str);
 char		*trimm(char *split);











--- a/parsing/redirections.c
char	**two(char **split, int *code, int i)
 	if (!split[i])
 		return (ft_free_arr(split, arr_size(split)), NULL);
 	i++;
-	if (!split[i] || (split[i] && is_problem_char(split[i]) == 1))
+	if (!split[i] || (split[i] && is_problem_char(split[i], code) == 1))
 	{
 		if (!split[i])
 		{
@@ -29,6 +29,7 @@ char	**two(char **split, int *code, int i)
 		ft_free_arr(split, arr_size(split));
 		return (NULL);
 	}
+	i = skip_ispaces(split, ++i);
 	limiter(split[i]);
 	split[i] = ft_strdup(TMP_FILE);
 	return (split);
